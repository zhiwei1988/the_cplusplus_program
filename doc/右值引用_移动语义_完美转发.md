## 理解 std::move 和 std::forward

std::move 和 std::forward 都是仅仅执行强制型别转换的函数（其实是函数模板）。 std::move 无条件地将实参强制转换成右值， 而 std::forward 则仅在某个特定条件满 足时才执行同一个强制转换。

右值是可以实施移动的，所以在一个对象上实施了 std::move, 就是告诉编译器该对象具备可移动的条件。

指涉到常量的左值引用允许绑定到一个常量右值型别的形参。

如果想取得对某个对象执行移动操作的能力，则不要将其声明为常量，因为针对常量对象执行的移动操作将一声不响地变换成复制操作；std::move 不仅不实际移动任何东西，甚至不保证经过其强制型别转换后的对象具备可移动的能力。

```cpp
void process(const Widget& lvalArg);
void process(Widget&& rvalArg);

template <typename T>
void logAndProcess(T&& param)
{
    auto now = std::chrono::system_clock::now();
    makeLogEntry("Calling 'process'", now);
    // 所有函数的型参皆是左值，如果不使用 std::forward
    // 那么所有对 logAndProcess 的调用都会取左值类型的那个版本
    process(std::forward<T>(param));
}

Widget w;
logAndProcess(w); // 调用时传入左值
logAndProcess(std::move(w)); // 调用时传入右值
```

std::forward 仅当其实参是使用右值完成初始化时，它才会执行向右值类型的强制类型转换。那么，std::forward 是如何辨别 param 是通过左值还是右值完成了初始化的呢？一句话：该信息是被编码到 logAndProcess 的模版型参 T 中的。该型参被传递给 std::forward 后，随即由后者将编码信息恢复出来。

